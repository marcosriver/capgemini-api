{"ast":null,"code":"var _createForOfIteratorHelper = require(\"C:/Users/Marcos/Desktop/capgmenini-api/frontend/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _classCallCheck = require(\"C:/Users/Marcos/Desktop/capgmenini-api/frontend/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/Marcos/Desktop/capgmenini-api/frontend/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _inherits = require(\"C:/Users/Marcos/Desktop/capgmenini-api/frontend/node_modules/@babel/runtime/helpers/inherits.js\").default;\n\nvar _createSuper = require(\"C:/Users/Marcos/Desktop/capgmenini-api/frontend/node_modules/@babel/runtime/helpers/createSuper.js\").default;\n\nvar _require = require('postcss'),\n    list = _require.list;\n\nvar OldSelector = require('./old-selector');\n\nvar Prefixer = require('./prefixer');\n\nvar Browsers = require('./browsers');\n\nvar utils = require('./utils');\n\nvar Selector = /*#__PURE__*/function (_Prefixer) {\n  \"use strict\";\n\n  _inherits(Selector, _Prefixer);\n\n  var _super = _createSuper(Selector);\n\n  function Selector(name, prefixes, all) {\n    var _this;\n\n    _classCallCheck(this, Selector);\n\n    _this = _super.call(this, name, prefixes, all);\n    _this.regexpCache = new Map();\n    return _this;\n  }\n  /**\n   * Is rule selectors need to be prefixed\n   */\n\n\n  _createClass(Selector, [{\n    key: \"check\",\n    value: function check(rule) {\n      if (rule.selector.includes(this.name)) {\n        return !!rule.selector.match(this.regexp());\n      }\n\n      return false;\n    }\n    /**\n     * Return prefixed version of selector\n     */\n\n  }, {\n    key: \"prefixed\",\n    value: function prefixed(prefix) {\n      return this.name.replace(/^(\\W*)/, \"$1\".concat(prefix));\n    }\n    /**\n     * Lazy loadRegExp for name\n     */\n\n  }, {\n    key: \"regexp\",\n    value: function regexp(prefix) {\n      if (!this.regexpCache.has(prefix)) {\n        var name = prefix ? this.prefixed(prefix) : this.name;\n        this.regexpCache.set(prefix, new RegExp(\"(^|[^:\\\"'=])\".concat(utils.escapeRegexp(name)), 'gi'));\n      }\n\n      return this.regexpCache.get(prefix);\n    }\n    /**\n     * All possible prefixes\n     */\n\n  }, {\n    key: \"possible\",\n    value: function possible() {\n      return Browsers.prefixes();\n    }\n    /**\n     * Return all possible selector prefixes\n     */\n\n  }, {\n    key: \"prefixeds\",\n    value: function prefixeds(rule) {\n      var _this2 = this;\n\n      if (rule._autoprefixerPrefixeds) {\n        if (rule._autoprefixerPrefixeds[this.name]) {\n          return rule._autoprefixerPrefixeds;\n        }\n      } else {\n        rule._autoprefixerPrefixeds = {};\n      }\n\n      var prefixeds = {};\n\n      if (rule.selector.includes(',')) {\n        var ruleParts = list.comma(rule.selector);\n        var toProcess = ruleParts.filter(function (el) {\n          return el.includes(_this2.name);\n        });\n\n        var _iterator = _createForOfIteratorHelper(this.possible()),\n            _step;\n\n        try {\n          var _loop = function _loop() {\n            var prefix = _step.value;\n            prefixeds[prefix] = toProcess.map(function (el) {\n              return _this2.replace(el, prefix);\n            }).join(', ');\n          };\n\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            _loop();\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      } else {\n        var _iterator2 = _createForOfIteratorHelper(this.possible()),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var prefix = _step2.value;\n            prefixeds[prefix] = this.replace(rule.selector, prefix);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n\n      rule._autoprefixerPrefixeds[this.name] = prefixeds;\n      return rule._autoprefixerPrefixeds;\n    }\n    /**\n     * Is rule already prefixed before\n     */\n\n  }, {\n    key: \"already\",\n    value: function already(rule, prefixeds, prefix) {\n      var index = rule.parent.index(rule) - 1;\n\n      while (index >= 0) {\n        var before = rule.parent.nodes[index];\n\n        if (before.type !== 'rule') {\n          return false;\n        }\n\n        var some = false;\n\n        for (var key in prefixeds[this.name]) {\n          var prefixed = prefixeds[this.name][key];\n\n          if (before.selector === prefixed) {\n            if (prefix === key) {\n              return true;\n            } else {\n              some = true;\n              break;\n            }\n          }\n        }\n\n        if (!some) {\n          return false;\n        }\n\n        index -= 1;\n      }\n\n      return false;\n    }\n    /**\n     * Replace selectors by prefixed one\n     */\n\n  }, {\n    key: \"replace\",\n    value: function replace(selector, prefix) {\n      return selector.replace(this.regexp(), \"$1\".concat(this.prefixed(prefix)));\n    }\n    /**\n     * Clone and add prefixes for at-rule\n     */\n\n  }, {\n    key: \"add\",\n    value: function add(rule, prefix) {\n      var prefixeds = this.prefixeds(rule);\n\n      if (this.already(rule, prefixeds, prefix)) {\n        return;\n      }\n\n      var cloned = this.clone(rule, {\n        selector: prefixeds[this.name][prefix]\n      });\n      rule.parent.insertBefore(rule, cloned);\n    }\n    /**\n     * Return function to fast find prefixed selector\n     */\n\n  }, {\n    key: \"old\",\n    value: function old(prefix) {\n      return new OldSelector(this, prefix);\n    }\n  }]);\n\n  return Selector;\n}(Prefixer);\n\nmodule.exports = Selector;","map":{"version":3,"names":["require","list","OldSelector","Prefixer","Browsers","utils","Selector","name","prefixes","all","regexpCache","Map","rule","selector","includes","match","regexp","prefix","replace","has","prefixed","set","RegExp","escapeRegexp","get","_autoprefixerPrefixeds","prefixeds","ruleParts","comma","toProcess","filter","el","possible","map","join","index","parent","before","nodes","type","some","key","already","cloned","clone","insertBefore","module","exports"],"sources":["C:/Users/Marcos/Desktop/capgmenini-api/frontend/node_modules/autoprefixer/lib/selector.js"],"sourcesContent":["let { list } = require('postcss')\n\nlet OldSelector = require('./old-selector')\nlet Prefixer = require('./prefixer')\nlet Browsers = require('./browsers')\nlet utils = require('./utils')\n\nclass Selector extends Prefixer {\n  constructor(name, prefixes, all) {\n    super(name, prefixes, all)\n    this.regexpCache = new Map()\n  }\n\n  /**\n   * Is rule selectors need to be prefixed\n   */\n  check(rule) {\n    if (rule.selector.includes(this.name)) {\n      return !!rule.selector.match(this.regexp())\n    }\n\n    return false\n  }\n\n  /**\n   * Return prefixed version of selector\n   */\n  prefixed(prefix) {\n    return this.name.replace(/^(\\W*)/, `$1${prefix}`)\n  }\n\n  /**\n   * Lazy loadRegExp for name\n   */\n  regexp(prefix) {\n    if (!this.regexpCache.has(prefix)) {\n      let name = prefix ? this.prefixed(prefix) : this.name\n      this.regexpCache.set(\n        prefix,\n        new RegExp(`(^|[^:\"'=])${utils.escapeRegexp(name)}`, 'gi')\n      )\n    }\n\n    return this.regexpCache.get(prefix)\n  }\n\n  /**\n   * All possible prefixes\n   */\n  possible() {\n    return Browsers.prefixes()\n  }\n\n  /**\n   * Return all possible selector prefixes\n   */\n  prefixeds(rule) {\n    if (rule._autoprefixerPrefixeds) {\n      if (rule._autoprefixerPrefixeds[this.name]) {\n        return rule._autoprefixerPrefixeds\n      }\n    } else {\n      rule._autoprefixerPrefixeds = {}\n    }\n\n    let prefixeds = {}\n    if (rule.selector.includes(',')) {\n      let ruleParts = list.comma(rule.selector)\n      let toProcess = ruleParts.filter(el => el.includes(this.name))\n\n      for (let prefix of this.possible()) {\n        prefixeds[prefix] = toProcess\n          .map(el => this.replace(el, prefix))\n          .join(', ')\n      }\n    } else {\n      for (let prefix of this.possible()) {\n        prefixeds[prefix] = this.replace(rule.selector, prefix)\n      }\n    }\n\n    rule._autoprefixerPrefixeds[this.name] = prefixeds\n    return rule._autoprefixerPrefixeds\n  }\n\n  /**\n   * Is rule already prefixed before\n   */\n  already(rule, prefixeds, prefix) {\n    let index = rule.parent.index(rule) - 1\n\n    while (index >= 0) {\n      let before = rule.parent.nodes[index]\n\n      if (before.type !== 'rule') {\n        return false\n      }\n\n      let some = false\n      for (let key in prefixeds[this.name]) {\n        let prefixed = prefixeds[this.name][key]\n        if (before.selector === prefixed) {\n          if (prefix === key) {\n            return true\n          } else {\n            some = true\n            break\n          }\n        }\n      }\n      if (!some) {\n        return false\n      }\n\n      index -= 1\n    }\n\n    return false\n  }\n\n  /**\n   * Replace selectors by prefixed one\n   */\n  replace(selector, prefix) {\n    return selector.replace(this.regexp(), `$1${this.prefixed(prefix)}`)\n  }\n\n  /**\n   * Clone and add prefixes for at-rule\n   */\n  add(rule, prefix) {\n    let prefixeds = this.prefixeds(rule)\n\n    if (this.already(rule, prefixeds, prefix)) {\n      return\n    }\n\n    let cloned = this.clone(rule, { selector: prefixeds[this.name][prefix] })\n    rule.parent.insertBefore(rule, cloned)\n  }\n\n  /**\n   * Return function to fast find prefixed selector\n   */\n  old(prefix) {\n    return new OldSelector(this, prefix)\n  }\n}\n\nmodule.exports = Selector\n"],"mappings":";;;;;;;;;;AAAA,eAAeA,OAAO,CAAC,SAAD,CAAtB;AAAA,IAAMC,IAAN,YAAMA,IAAN;;AAEA,IAAIC,WAAW,GAAGF,OAAO,CAAC,gBAAD,CAAzB;;AACA,IAAIG,QAAQ,GAAGH,OAAO,CAAC,YAAD,CAAtB;;AACA,IAAII,QAAQ,GAAGJ,OAAO,CAAC,YAAD,CAAtB;;AACA,IAAIK,KAAK,GAAGL,OAAO,CAAC,SAAD,CAAnB;;IAEMM,Q;;;;;;;EACJ,kBAAYC,IAAZ,EAAkBC,QAAlB,EAA4BC,GAA5B,EAAiC;IAAA;;IAAA;;IAC/B,0BAAMF,IAAN,EAAYC,QAAZ,EAAsBC,GAAtB;IACA,MAAKC,WAAL,GAAmB,IAAIC,GAAJ,EAAnB;IAF+B;EAGhC;EAED;AACF;AACA;;;;;WACE,eAAMC,IAAN,EAAY;MACV,IAAIA,IAAI,CAACC,QAAL,CAAcC,QAAd,CAAuB,KAAKP,IAA5B,CAAJ,EAAuC;QACrC,OAAO,CAAC,CAACK,IAAI,CAACC,QAAL,CAAcE,KAAd,CAAoB,KAAKC,MAAL,EAApB,CAAT;MACD;;MAED,OAAO,KAAP;IACD;IAED;AACF;AACA;;;;WACE,kBAASC,MAAT,EAAiB;MACf,OAAO,KAAKV,IAAL,CAAUW,OAAV,CAAkB,QAAlB,cAAiCD,MAAjC,EAAP;IACD;IAED;AACF;AACA;;;;WACE,gBAAOA,MAAP,EAAe;MACb,IAAI,CAAC,KAAKP,WAAL,CAAiBS,GAAjB,CAAqBF,MAArB,CAAL,EAAmC;QACjC,IAAIV,IAAI,GAAGU,MAAM,GAAG,KAAKG,QAAL,CAAcH,MAAd,CAAH,GAA2B,KAAKV,IAAjD;QACA,KAAKG,WAAL,CAAiBW,GAAjB,CACEJ,MADF,EAEE,IAAIK,MAAJ,uBAAyBjB,KAAK,CAACkB,YAAN,CAAmBhB,IAAnB,CAAzB,GAAqD,IAArD,CAFF;MAID;;MAED,OAAO,KAAKG,WAAL,CAAiBc,GAAjB,CAAqBP,MAArB,CAAP;IACD;IAED;AACF;AACA;;;;WACE,oBAAW;MACT,OAAOb,QAAQ,CAACI,QAAT,EAAP;IACD;IAED;AACF;AACA;;;;WACE,mBAAUI,IAAV,EAAgB;MAAA;;MACd,IAAIA,IAAI,CAACa,sBAAT,EAAiC;QAC/B,IAAIb,IAAI,CAACa,sBAAL,CAA4B,KAAKlB,IAAjC,CAAJ,EAA4C;UAC1C,OAAOK,IAAI,CAACa,sBAAZ;QACD;MACF,CAJD,MAIO;QACLb,IAAI,CAACa,sBAAL,GAA8B,EAA9B;MACD;;MAED,IAAIC,SAAS,GAAG,EAAhB;;MACA,IAAId,IAAI,CAACC,QAAL,CAAcC,QAAd,CAAuB,GAAvB,CAAJ,EAAiC;QAC/B,IAAIa,SAAS,GAAG1B,IAAI,CAAC2B,KAAL,CAAWhB,IAAI,CAACC,QAAhB,CAAhB;QACA,IAAIgB,SAAS,GAAGF,SAAS,CAACG,MAAV,CAAiB,UAAAC,EAAE;UAAA,OAAIA,EAAE,CAACjB,QAAH,CAAY,MAAI,CAACP,IAAjB,CAAJ;QAAA,CAAnB,CAAhB;;QAF+B,2CAIZ,KAAKyB,QAAL,EAJY;QAAA;;QAAA;UAAA;YAAA,IAItBf,MAJsB;YAK7BS,SAAS,CAACT,MAAD,CAAT,GAAoBY,SAAS,CAC1BI,GADiB,CACb,UAAAF,EAAE;cAAA,OAAI,MAAI,CAACb,OAAL,CAAaa,EAAb,EAAiBd,MAAjB,CAAJ;YAAA,CADW,EAEjBiB,IAFiB,CAEZ,IAFY,CAApB;UAL6B;;UAI/B,oDAAoC;YAAA;UAInC;QAR8B;UAAA;QAAA;UAAA;QAAA;MAShC,CATD,MASO;QAAA,4CACc,KAAKF,QAAL,EADd;QAAA;;QAAA;UACL,uDAAoC;YAAA,IAA3Bf,MAA2B;YAClCS,SAAS,CAACT,MAAD,CAAT,GAAoB,KAAKC,OAAL,CAAaN,IAAI,CAACC,QAAlB,EAA4BI,MAA5B,CAApB;UACD;QAHI;UAAA;QAAA;UAAA;QAAA;MAIN;;MAEDL,IAAI,CAACa,sBAAL,CAA4B,KAAKlB,IAAjC,IAAyCmB,SAAzC;MACA,OAAOd,IAAI,CAACa,sBAAZ;IACD;IAED;AACF;AACA;;;;WACE,iBAAQb,IAAR,EAAcc,SAAd,EAAyBT,MAAzB,EAAiC;MAC/B,IAAIkB,KAAK,GAAGvB,IAAI,CAACwB,MAAL,CAAYD,KAAZ,CAAkBvB,IAAlB,IAA0B,CAAtC;;MAEA,OAAOuB,KAAK,IAAI,CAAhB,EAAmB;QACjB,IAAIE,MAAM,GAAGzB,IAAI,CAACwB,MAAL,CAAYE,KAAZ,CAAkBH,KAAlB,CAAb;;QAEA,IAAIE,MAAM,CAACE,IAAP,KAAgB,MAApB,EAA4B;UAC1B,OAAO,KAAP;QACD;;QAED,IAAIC,IAAI,GAAG,KAAX;;QACA,KAAK,IAAIC,GAAT,IAAgBf,SAAS,CAAC,KAAKnB,IAAN,CAAzB,EAAsC;UACpC,IAAIa,QAAQ,GAAGM,SAAS,CAAC,KAAKnB,IAAN,CAAT,CAAqBkC,GAArB,CAAf;;UACA,IAAIJ,MAAM,CAACxB,QAAP,KAAoBO,QAAxB,EAAkC;YAChC,IAAIH,MAAM,KAAKwB,GAAf,EAAoB;cAClB,OAAO,IAAP;YACD,CAFD,MAEO;cACLD,IAAI,GAAG,IAAP;cACA;YACD;UACF;QACF;;QACD,IAAI,CAACA,IAAL,EAAW;UACT,OAAO,KAAP;QACD;;QAEDL,KAAK,IAAI,CAAT;MACD;;MAED,OAAO,KAAP;IACD;IAED;AACF;AACA;;;;WACE,iBAAQtB,QAAR,EAAkBI,MAAlB,EAA0B;MACxB,OAAOJ,QAAQ,CAACK,OAAT,CAAiB,KAAKF,MAAL,EAAjB,cAAqC,KAAKI,QAAL,CAAcH,MAAd,CAArC,EAAP;IACD;IAED;AACF;AACA;;;;WACE,aAAIL,IAAJ,EAAUK,MAAV,EAAkB;MAChB,IAAIS,SAAS,GAAG,KAAKA,SAAL,CAAed,IAAf,CAAhB;;MAEA,IAAI,KAAK8B,OAAL,CAAa9B,IAAb,EAAmBc,SAAnB,EAA8BT,MAA9B,CAAJ,EAA2C;QACzC;MACD;;MAED,IAAI0B,MAAM,GAAG,KAAKC,KAAL,CAAWhC,IAAX,EAAiB;QAAEC,QAAQ,EAAEa,SAAS,CAAC,KAAKnB,IAAN,CAAT,CAAqBU,MAArB;MAAZ,CAAjB,CAAb;MACAL,IAAI,CAACwB,MAAL,CAAYS,YAAZ,CAAyBjC,IAAzB,EAA+B+B,MAA/B;IACD;IAED;AACF;AACA;;;;WACE,aAAI1B,MAAJ,EAAY;MACV,OAAO,IAAIf,WAAJ,CAAgB,IAAhB,EAAsBe,MAAtB,CAAP;IACD;;;;EA3IoBd,Q;;AA8IvB2C,MAAM,CAACC,OAAP,GAAiBzC,QAAjB"},"metadata":{},"sourceType":"script"}